{"version":3,"file":"static/js/7286.d24a2bd0.chunk.js","mappings":"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","sources":["../node_modules/use-debounce/src/useDebouncedCallback.ts","../node_modules/use-debounce/src/useDebounce.ts","../node_modules/@tanstack/virtual-core/src/utils.ts","../node_modules/@tanstack/virtual-core/src/index.ts","../node_modules/@tanstack/react-virtual/src/index.tsx","../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/react-query/src/useQueries.ts"],"sourcesContent":["import {\n  useRef,\n  useEffect,\n  useMemo,\n  type Dispatch,\n  type SetStateAction,\n} from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n  /**\n   * Controls if the function should be invoked when the React component unmounts or\n   * the page is closed. This is usually desirable whenever `func` has persistent side-effects\n   * such as persists data.\n   *\n   * NOTE: If the callback calls `fetch()`, you usually also want to specify the `keepalive=true`\n   * option for `fetch()` so it can finish in the background after the page is closed.\n   *\n   * This option has no effect if `trailing == false`.\n   */\n  flushOnExit?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n  /**\n   * If the setting is set to true, all debouncing and timers will happen on the server side as well\n   */\n  debounceOnServer?: boolean;\n}\n\nexport interface ControlFunctions<ReturnT> {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => ReturnT | undefined;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function return the result of the last func invocation.\n * Note, that if there are no previous invocations you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>>\n  extends ControlFunctions<ReturnType<T>> {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.isPending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(\n  func: T,\n  wait?: number,\n  options?: Options,\n  forceUpdate?: Dispatch<SetStateAction<object>>\n): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const firstInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n  const visibilityListener = useRef<VoidFunction>();\n  const debouncedRef = useRef<DebouncedState<T>>();\n  // Always keep the latest version of debounce callback, with no wait time.\n  funcRef.current = func;\n\n  const isClientSide = typeof window !== 'undefined';\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && isClientSide;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const flushOnExit = !!options.flushOnExit && trailing;\n  const maxing = 'maxWait' in options;\n  const debounceOnServer =\n    'debounceOnServer' in options ? !!options.debounceOnServer : false; // `false` by default\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      firstInvokeTime.current = firstInvokeTime.current || time;\n\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF\n        ? requestAnimationFrame(pendingFunc)\n        : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n\n      if (leading && firstInvokeTime.current === lastInvokeTime.current) {\n        notifyManuallyTimerExpired();\n      }\n\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const notifyManuallyTimerExpired = () => {\n      if (forceUpdate) {\n        forceUpdate({});\n      }\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      if (!isClientSide && !debounceOnServer) {\n        return;\n      }\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (flushOnExit && !visibilityListener.current) {\n        visibilityListener.current = () => {\n          if (global.document?.visibilityState === 'hidden') {\n            debouncedRef.current.flush();\n          }\n        };\n        global.document?.addEventListener?.(\n          'visibilitychange',\n          visibilityListener.current\n        );\n      }\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      const hadTimer = timerId.current;\n      if (hadTimer) {\n        useRAF\n          ? cancelAnimationFrame(timerId.current)\n          : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current =\n        lastCallTime.current =\n        lastThis.current =\n        timerId.current =\n          null;\n\n      // Notify React to re-render when cancel is called and there was an active timer\n      if (hadTimer && forceUpdate) {\n        forceUpdate({});\n      }\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [\n    leading,\n    maxing,\n    wait,\n    maxWait,\n    trailing,\n    flushOnExit,\n    useRAF,\n    isClientSide,\n    debounceOnServer,\n    forceUpdate,\n  ]);\n\n  // Store reference to debounced function for cleanup\n  debouncedRef.current = debounced;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      if (flushOnExit) {\n        debouncedRef.current.flush();\n      }\n      if (visibilityListener.current) {\n        global.document?.removeEventListener?.(\n          'visibilitychange',\n          visibilityListener.current\n        );\n        visibilityListener.current = null;\n      }\n      mounted.current = false;\n    };\n  }, [flushOnExit]);\n\n  return debounced;\n}\n","import { useCallback, useRef, useState } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: {\n    maxWait?: number;\n    leading?: boolean;\n    trailing?: boolean;\n    equalityFn?: (left: T, right: T) => boolean;\n  }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const activeValue = useRef(value);\n  const [, forceUpdate] = useState({});\n  const debounced = useDebouncedCallback(\n    useCallback(\n      (value: T) => {\n        activeValue.current = value;\n        forceUpdate({});\n      },\n      [forceUpdate]\n    ),\n    delay,\n    options,\n    forceUpdate\n  );\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  return [activeValue.current as T, debounced];\n}\n","export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => boolean\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n    skipInitialOnChange?: boolean\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n  let isInitial = true\n\n  function memoizedFunction(): TResult {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    if (opts?.onChange && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result)\n    }\n\n    isInitial = false\n\n    return result\n  }\n\n  // Attach updateDeps to the function itself\n  memoizedFunction.updateDeps = (newDeps: [...TDeps]) => {\n    deps = newDeps\n  }\n\n  return memoizedFunction\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1.01\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n","import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nconst getRect = (element: HTMLElement): Rect => {\n  const { offsetWidth, offsetHeight } = element\n  return { width: offsetWidth, height: offsetHeight }\n}\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(getRect(element as unknown as HTMLElement))\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0]\n      if (entry?.borderBoxSize) {\n        const box = entry.borderBoxSize[0]\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize })\n          return\n        }\n      }\n      handler(getRect(element as unknown as HTMLElement))\n    }\n\n    instance.options.useAnimationFrameWithResizeObserver\n      ? requestAnimationFrame(run)\n      : run()\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n\n  return (element as unknown as HTMLElement)[\n    instance.options.horizontal ? 'offsetWidth' : 'offsetHeight'\n  ]\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n  useAnimationFrameWithResizeObserver?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private currentScrollToIndex: number | null = null\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private laneAssignments = new Map<number, number>() // index â†’ lane cache\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  private prevLanes: number | undefined = undefined\n  private lanesChangedFlag = false\n  private lanesSettling = false\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          const run = () => {\n            this._measureElement(entry.target as TItemElement, entry)\n          }\n          this.options.useAnimationFrameWithResizeObserver\n            ? requestAnimationFrame(run)\n            : run()\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: false,\n      useAnimationFrameWithResizeObserver: false,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n      this.options.lanes,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {\n      const lanesChanged =\n        this.prevLanes !== undefined && this.prevLanes !== lanes\n\n      if (lanesChanged) {\n        // Set flag for getMeasurements to handle\n        this.lanesChangedFlag = true\n      }\n\n      this.prevLanes = lanes\n      this.pendingMeasuredCacheIndexes = []\n\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n        lanes,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled, lanes },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear()\n        return []\n      }\n\n      // Clean up stale lane cache entries when count decreases\n      if (this.laneAssignments.size > count) {\n        for (const index of this.laneAssignments.keys()) {\n          if (index >= count) {\n            this.laneAssignments.delete(index)\n          }\n        }\n      }\n\n      // âœ… Force complete recalculation when lanes change\n      if (this.lanesChangedFlag) {\n        this.lanesChangedFlag = false // Reset immediately\n        this.lanesSettling = true // Start settling period\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear() // Clear lane cache for new lane count\n        // Clear pending indexes to force min = 0\n        this.pendingMeasuredCacheIndexes = []\n      }\n\n      // Don't restore from initialMeasurementsCache during lane changes\n      // as it contains stale lane assignments from the previous lane count\n      if (this.measurementsCache.length === 0 && !this.lanesSettling) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      // âœ… During lanes settling, ignore pendingMeasuredCacheIndexes to prevent repositioning\n      const min = this.lanesSettling\n        ? 0\n        : this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      // âœ… End settling period when cache is fully built\n      if (this.lanesSettling && this.measurementsCache.length === count) {\n        this.lanesSettling = false\n      }\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      // âœ… Performance: Track last item index per lane for O(1) lookup\n      const laneLastIndex: Array<number | undefined> = new Array(lanes).fill(\n        undefined,\n      )\n\n      // Initialize from existing measurements (before min)\n      for (let m = 0; m < min; m++) {\n        const item = measurements[m]\n        if (item) {\n          laneLastIndex[item.lane] = m\n        }\n      }\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        // Check for cached lane assignment\n        const cachedLane = this.laneAssignments.get(i)\n        let lane: number\n        let start: number\n\n        if (cachedLane !== undefined && this.options.lanes > 1) {\n          // Use cached lane - O(1) lookup for previous item in same lane\n          lane = cachedLane\n          const prevIndex = laneLastIndex[lane]\n          const prevInLane =\n            prevIndex !== undefined ? measurements[prevIndex] : undefined\n          start = prevInLane\n            ? prevInLane.end + this.options.gap\n            : paddingStart + scrollMargin\n        } else {\n          // No cache - use original logic (find shortest lane)\n          const furthestMeasurement =\n            this.options.lanes === 1\n              ? measurements[i - 1]\n              : this.getFurthestMeasurement(measurements, i)\n\n          start = furthestMeasurement\n            ? furthestMeasurement.end + this.options.gap\n            : paddingStart + scrollMargin\n\n          lane = furthestMeasurement\n            ? furthestMeasurement.lane\n            : i % this.options.lanes\n\n          // Cache the lane assignment\n          if (this.options.lanes > 1) {\n            this.laneAssignments.set(i, lane)\n          }\n        }\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n\n        // âœ… Performance: Update lane's last item index\n        laneLastIndex[lane] = i\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [\n      this.getMeasurements(),\n      this.getSize(),\n      this.getScrollOffset(),\n      this.options.lanes,\n    ],\n    (measurements, outerSize, scrollOffset, lanes) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n              lanes,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualIndexes = memo(\n    () => {\n      let startIndex: number | null = null\n      let endIndex: number | null = null\n      const range = this.calculateRange()\n      if (range) {\n        startIndex = range.startIndex\n        endIndex = range.endIndex\n      }\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex])\n      return [\n        this.options.rangeExtractor,\n        this.options.overscan,\n        this.options.count,\n        startIndex,\n        endIndex,\n      ]\n    },\n    (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null\n        ? []\n        : rangeExtractor({\n            startIndex,\n            endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getVirtualIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  private getMaxScrollOffset = () => {\n    if (!this.scrollElement) return 0\n\n    if ('scrollHeight' in this.scrollElement) {\n      // Element\n      return this.options.horizontal\n        ? this.scrollElement.scrollWidth - this.scrollElement.clientWidth\n        : this.scrollElement.scrollHeight - this.scrollElement.clientHeight\n    } else {\n      // Window\n      const doc = this.scrollElement.document.documentElement\n      return this.options.horizontal\n        ? doc.scrollWidth - this.scrollElement.innerWidth\n        : doc.scrollHeight - this.scrollElement.innerHeight\n    }\n  }\n\n  getOffsetForAlignment = (\n    toOffset: number,\n    align: ScrollAlignment,\n    itemSize = 0,\n  ) => {\n    if (!this.scrollElement) return 0\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      align = toOffset >= scrollOffset + size ? 'end' : 'start'\n    }\n\n    if (align === 'center') {\n      // When aligning to a particular item (e.g. with scrollToIndex),\n      // adjust offset by the size of the item to center on the item\n      toOffset += (itemSize - size) / 2\n    } else if (align === 'end') {\n      toOffset -= size\n    }\n\n    const maxOffset = this.getMaxScrollOffset()\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    // For the last item with 'end' alignment, use browser's actual max scroll\n    // to account for borders/padding that aren't in our measurements\n    if (align === 'end' && index === this.options.count - 1) {\n      return [this.getMaxScrollOffset(), align] as const\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [\n      this.getOffsetForAlignment(toOffset, align, item.size),\n      align,\n    ] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n    this.currentScrollToIndex = index\n\n    let attempts = 0\n    const maxAttempts = 10\n\n    const tryScroll = (currentAlign: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      const offsetInfo = this.getOffsetForIndex(index, currentAlign)\n      if (!offsetInfo) {\n        console.warn('Failed to get offset for index:', index)\n        return\n      }\n      const [offset, align] = offsetInfo\n      this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n      this.targetWindow.requestAnimationFrame(() => {\n        const verify = () => {\n          // Abort if a new scrollToIndex was called with a different index\n          if (this.currentScrollToIndex !== index) return\n\n          const currentOffset = this.getScrollOffset()\n          const afterInfo = this.getOffsetForIndex(index, align)\n          if (!afterInfo) {\n            console.warn('Failed to get offset for index:', index)\n            return\n          }\n\n          if (!approxEqual(afterInfo[0], currentOffset)) {\n            scheduleRetry(align)\n          }\n        }\n\n        // In dynamic mode, wait an extra frame for ResizeObserver to measure newly visible elements\n        if (this.isDynamicMode()) {\n          this.targetWindow!.requestAnimationFrame(verify)\n        } else {\n          verify()\n        }\n      })\n    }\n\n    const scheduleRetry = (align: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      // Abort if a new scrollToIndex was called with a different index\n      if (this.currentScrollToIndex !== index) return\n\n      attempts++\n      if (attempts < maxAttempts) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('Schedule retry', attempts, maxAttempts)\n        }\n        this.targetWindow.requestAnimationFrame(() => tryScroll(align))\n      } else {\n        console.warn(\n          `Failed to scroll to index ${index} after ${maxAttempts} attempts.`,\n        )\n      }\n    }\n\n    tryScroll(initialAlign)\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    // If there is only one lane, use the last measurement's end\n    // Otherwise find the maximum end value among all measurements\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else if (this.options.lanes === 1) {\n      end = measurements[measurements.length - 1]?.end ?? 0\n    } else {\n      const endByLane = Array<number | null>(this.options.lanes).fill(null)\n      let endIndex = measurements.length - 1\n      while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n        const item = measurements[endIndex]!\n        if (endByLane[item.lane] === null) {\n          endByLane[item.lane] = item.end\n        }\n\n        endIndex--\n      }\n\n      end = Math.max(...endByLane.filter((val): val is number => val !== null))\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.laneAssignments = new Map() // Clear lane cache for full re-layout\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n  lanes: number\n}) {\n  const lastIndex = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  // handle case when item count is less than or equal to lanes\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex,\n    }\n  }\n\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset,\n  )\n  let endIndex = startIndex\n\n  if (lanes === 1) {\n    while (\n      endIndex < lastIndex &&\n      measurements[endIndex]!.end < scrollOffset + outerSize\n    ) {\n      endIndex++\n    }\n  } else if (lanes > 1) {\n    // Expand forward until we include the visible items from all lanes\n    // which are closer to the end of the virtualizer window\n    const endPerLane = Array(lanes).fill(0)\n    while (\n      endIndex < lastIndex &&\n      endPerLane.some((pos) => pos < scrollOffset + outerSize)\n    ) {\n      const item = measurements[endIndex]!\n      endPerLane[item.lane] = item.end\n      endIndex++\n    }\n\n    // Expand backward until we include all lanes' visible items\n    // closer to the top\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize)\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex]!\n      startPerLane[item.lane] = item.start\n      startIndex--\n    }\n\n    // Align startIndex to the beginning of its lane\n    startIndex = Math.max(0, startIndex - (startIndex % lanes))\n    // Align endIndex to the end of its lane\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - (endIndex % lanes)))\n  }\n\n  return { startIndex, endIndex }\n}\n","import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport type ReactVirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> = VirtualizerOptions<TScrollElement, TItemElement> & {\n  useFlushSync?: boolean\n}\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>({\n  useFlushSync = true,\n  ...options\n}: ReactVirtualizerOptions<TScrollElement, TItemElement>): Virtualizer<\n  TScrollElement,\n  TItemElement\n> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (useFlushSync && sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    ReactVirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    ReactVirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.observers\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const matchingObserversSet = new Set(\n      matchingObservers.map((match) => match.observer),\n    )\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) => !matchingObserversSet.has(prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","'use client'\nimport * as React from 'react'\n\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type { OmitKeyof, QueryFunction, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'context'\n>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n    ? DefinedUseQueryResult<TData, TError>\n    : TInitialData extends () => infer TInitialDataResult\n    ? unknown extends TInitialDataResult\n      ? UseQueryResult<TData, TError>\n      : TInitialDataResult extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : UseQueryResult<TData, TError>\n    : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? GetDefinedOrUndefinedQueryResult<T, TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  TResult extends any[] = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResult, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...TResult, GetOptions<Head>], [...TDepth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  TResults extends any[] = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResults, GetUseQueryResult<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<\n      [...Tail],\n      [...TResults, GetUseQueryResult<Head>],\n      [...TDepth, 1]\n    >\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n"],"names":["c","e","u","i","l","a","r","o","f","v","d","m","s","g","h","x","E","current","b","window","p","TypeError","y","leading","w","trailing","O","flushOnExit","F","L","debounceOnServer","A","Math","max","maxWait","D","n","t","apply","cancelAnimationFrame","requestAnimationFrame","setTimeout","Date","now","min","S","slice","call","arguments","global","document","visibilityState","flush","addEventListener","cancel","clearTimeout","isPending","removeEventListener","equalityFn","memo","getDeps","fn","opts","result","deps","initialDeps","isInitial","memoizedFunction","_a","_b","_c","depTime","key","debug","newDeps","length","some","dep","index","resultTime","depEndTime","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","onChange","skipInitialOnChange","updateDeps","notUndefined","value","msg","Error","debounce","targetWindow","ms","timeoutId","args","this","getRect","element","offsetWidth","offsetHeight","width","height","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","push","observeElementRect","instance","cb","scrollElement","handler","rect","ResizeObserver","observer","entries","run","entry","borderBoxSize","box","inlineSize","blockSize","options","useAnimationFrameWithResizeObserver","observe","unobserve","addEventListenerOptions","passive","supportsScrollend","observeElementOffset","offset","fallback","useScrollendEvent","isScrollingResetDelay","createHandler","isScrolling","horizontal","isRtl","endHandler","registerScrollendEvent","measureElement","elementScroll","adjustments","behavior","toOffset","scrollTo","Virtualizer","constructor","unsubs","currentScrollToIndex","measurementsCache","itemSizeCache","Map","laneAssignments","pendingMeasuredCacheIndexes","prevLanes","lanesChangedFlag","lanesSettling","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","sync","maybeNotify","calculateRange","process","cleanup","filter","Boolean","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","cached","getScrollOffset","_scrollToOffset","getSize","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","measurement","has","lane","previousFurthestMeasurement","set","size","Array","from","values","sort","getMeasurementOptions","getMeasurements","clear","keys","delete","item","laneLastIndex","fill","cachedLane","prevIndex","prevInLane","furthestMeasurement","measuredSize","estimateSize","outerSize","lastIndex","getOffset","findNearestBinarySearch","endPerLane","pos","startPerLane","getVirtualIndexes","indexFromElement","node","attributeName","indexStr","getAttribute","parseInt","warn","prevNode","isConnected","resizeItem","delta","shouldAdjustScrollPositionOnItemSizeChange","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","getMaxScrollOffset","scrollWidth","clientWidth","scrollHeight","clientHeight","doc","documentElement","innerWidth","innerHeight","getOffsetForAlignment","align","itemSize","maxOffset","getOffsetForIndex","isDynamicMode","scrollToOffset","scrollToIndex","initialAlign","attempts","tryScroll","currentAlign","offsetInfo","verify","currentOffset","afterInfo","approxEqual","abs","scheduleRetry","scrollBy","getTotalSize","endByLane","val","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","useIsomorphicLayoutEffect","React","useVirtualizerBase","useFlushSync","rerender","resolvedOptions","instance2","flushSync","useVirtualizer","QueriesObserver","Subscribable","client","queries","super","observers","observersMap","setQueries","onSubscribe","listeners","subscribe","onUpdate","onUnsubscribe","destroy","Set","notifyOptions","notifyManager","batch","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","queryHash","newResult","getCurrentResult","hasIndexChange","hasListeners","difference","getQueries","getCurrentQuery","getObservers","getOptimisticResult","prevObserversMap","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","QueryObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","concat","sortMatchesByOrderOfQueries","indexOf","replaceAt","listener","useQueries","context","defaultedQueries","_optimisticResults","isRestoring","query","ensurePreventErrorBoundaryRetry","errorResetBoundary","queryClient","optimisticResult","useSyncExternalStore","onStoreChange","batchCalls","suspensePromises","queryObserver","fetchOptimistic","Promise","all","observerQueries","_defaultedQueries$ind","_defaultedQueries$ind2","getHasError","firstSingleResultWhichShouldThrow","error"],"ignoreList":[],"sourceRoot":""}